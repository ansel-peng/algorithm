## Chapter Two

### 1.插入排序(Insertion Sort)

原理：构建有序序列，对于未排序数据，在已排序列中从后向前扫描，找到相应位置并插入

算法步骤:

1.输入一个无序数组，将第一个元素和第二个元素排序

2.将第三个元素取出，扫描已排序完的序列，在相应位置插入

3.循环，直到全部排完

动图演示：

![](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

复杂度：

|时间复杂度|空间复杂度|算法稳定性|
|---|---|---|
|O(n<sup>2</sup>)|O(1)|稳定|

---

### 2.选择排序(Selection Sort)

原理：找出最小的，放在第一位，找出次最小的，放在第二位，直到排完

算法步骤:

1.在未排序序列中找到最小(大)元素，存放到排序序列的起始位置。

2.再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。

3.重复2，直到所有元素均排序完毕

动图演示:

![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

复杂度:

|时间复杂度|空间复杂度|算法稳定性|
|---|---|---|
|O(n<sup>2</sup>)|O(1)|不稳定|

---

### 3.归并排序(Merge Sort)

原理:归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。

算法步骤:

1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列;

2.设定两个指针，最初位置分别为两个已经排序序列的起始位置;

3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；

4.重复步骤3直到某一指针达到序列尾;

5.将另一序列剩下的所有元素直接复制到合并序列尾。

动图演示:

![](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

复杂度:

|时间复杂度|空间复杂度|算法稳定性|
|---|---|---|
|O(n*lgn)|O(n)|稳定|

---

### 4.冒泡排序(Bubble Sort)

原理:重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

算法步骤:

1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2.对每一对相邻元素作同样的工作，从开始对第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3.针对所有的元素重复以上的步骤，除了最后一个。

4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

动图演示:

![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

|时间复杂度|空间复杂度|算法稳定性|
|---|---|---|
|O(n<sup>2</sup>)|O(1)|稳定|


